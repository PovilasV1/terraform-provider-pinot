package provider

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/hashicorp/terraform-plugin-testing/helper/acctest"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
)

func TestAccPinotTable_basic(t *testing.T) {
	rName := acctest.RandStringFromCharSet(10, acctest.CharSetAlphaNum)

	resource.Test(t, resource.TestCase{
		PreCheck:                 func() { testAccPreCheck(t) },
		ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
		CheckDestroy:             testAccCheckPinotTableDestroy,
		Steps: []resource.TestStep{
			{
				Config: testAccPinotTableConfig_basic(rName),
				Check: resource.ComposeTestCheckFunc(
					testAccCheckPinotTableExists("pinot_table.test"),
					resource.TestCheckResourceAttr("pinot_table.test", "table_name", rName),
					resource.TestCheckResourceAttr("pinot_table.test", "table_type", "OFFLINE"),
					resource.TestCheckResourceAttrSet("pinot_table.test", "table_config"),
				),
			},
			{
				ResourceName:      "pinot_table.test",
				ImportState:       true,
				ImportStateVerify: true,
			},
		},
	})
}

func TestAccPinotTable_realtime(t *testing.T) {
	// Gate this test unless specifically enabled (requires Kafka etc.)
	if os.Getenv("PINOT_TEST_REALTIME") == "" {
		t.Skip("set PINOT_TEST_REALTIME=1 to run realtime acceptance test (requires Kafka)")
	}

	rName := acctest.RandStringFromCharSet(10, acctest.CharSetAlphaNum)

	resource.Test(t, resource.TestCase{
		PreCheck:                 func() { testAccPreCheck(t) },
		ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
		CheckDestroy:             testAccCheckPinotTableDestroy,
		Steps: []resource.TestStep{
			{
				Config: testAccPinotTableConfig_realtime(rName),
				Check: resource.ComposeTestCheckFunc(
					testAccCheckPinotTableExists("pinot_table.test"),
					resource.TestCheckResourceAttr("pinot_table.test", "table_type", "REALTIME"),
				),
			},
		},
	})
}

// Common provider block so the provider is "explicitly configured".
// Values come from env vars inside the provider Configure().
// Keep this block empty unless you want to inject arguments directly.
const pinotProviderBlock = `
provider "pinot" {}
`

func testAccPinotTableConfig_basic(name string) string {
	return fmt.Sprintf(pinotProviderBlock+`
resource "pinot_schema" "test" {
  schema_name = "%[1]s"

  schema = jsonencode({
    schemaName                    = "%[1]s"
    enableColumnBasedNullHandling = false

    dimensionFieldSpecs = [
      {
        name      = "userId"
        dataType  = "STRING"
        fieldType = "DIMENSION"
        notNull   = false
      }
    ]

    metricFieldSpecs = [
      {
        name      = "count"
        dataType  = "LONG"
        fieldType = "METRIC"
        notNull   = false
      }
    ]

    dateTimeFieldSpecs = [
      {
        name        = "timestamp"
        dataType    = "LONG"
        format      = "1:MILLISECONDS:EPOCH"
        granularity = "1:HOURS"
        fieldType   = "DATE_TIME"
        notNull     = false
      }
    ]
  })
}

resource "pinot_table" "test" {
  table_name = "%[1]s"
  table_type = "OFFLINE"

  table_config = jsonencode({
    tableName = "%[1]s_OFFLINE"
    tableType = "OFFLINE"

    segmentsConfig = {
      minimizeDataMovement = false
      timeColumnName       = "timestamp"
      timeType             = "MILLISECONDS"
      schemaName           = "%[1]s"
      replication          = "1"
    }

    tenants = {
      broker = "DefaultTenant"
      server = "DefaultTenant"
    }

    tableIndexConfig = {
      aggregateMetrics                           = false
      autoGeneratedInvertedIndex                 = false
      columnMajorSegmentBuilderEnabled           = true
      createInvertedIndexDuringSegmentGeneration = false
      enableDefaultStarTree                      = false
      enableDynamicStarTreeCreation              = false
      noDictionarySizeRatioThreshold             = 0.85
      nullHandlingEnabled                        = false
      optimizeDictionary                         = false
      optimizeDictionaryForMetrics               = false
      optimizeDictionaryType                     = false
      rangeIndexVersion                          = 2
      loadMode                                   = "MMAP"
    }

    metadata = {
      customConfigs = {}
    }

    isDimTable = false
  })
}
`, name)
}

func testAccPinotTableConfig_realtime(name string) string {
	return fmt.Sprintf(pinotProviderBlock+`
resource "pinot_schema" "test" {
  schema_name = "%[1]s"

  schema = jsonencode({
    schemaName = "%[1]s"

    dimensionFieldSpecs = [
      {
        name     = "userId"
        dataType = "STRING"
      }
    ]

    metricFieldSpecs = [
      {
        name     = "count"
        dataType = "LONG"
      }
    ]

    dateTimeFieldSpecs = [
      {
        name        = "timestamp"
        dataType    = "LONG"
        format      = "1:MILLISECONDS:EPOCH"
        granularity = "1:HOURS"
      }
    ]
  })
}

resource "pinot_table" "test" {
  table_name = "%[1]s"
  table_type = "REALTIME"

  table_config = jsonencode({
    tableName = "%[1]s_REALTIME"
    tableType = "REALTIME"

    segmentsConfig = {
      minimizeDataMovement = false
      timeColumnName       = "timestamp"
      timeType             = "MILLISECONDS"
      schemaName           = "%[1]s"
      replication          = "1"
      replicasPerPartition = "1"
    }

    tenants = {
      broker = "DefaultTenant"
      server = "DefaultTenant"
    }

    tableIndexConfig = {
      aggregateMetrics                           = false
      autoGeneratedInvertedIndex                 = false
      columnMajorSegmentBuilderEnabled           = true
      createInvertedIndexDuringSegmentGeneration = false
      enableDefaultStarTree                      = false
      enableDynamicStarTreeCreation              = false
      noDictionarySizeRatioThreshold             = 0.85
      nullHandlingEnabled                        = false
      optimizeDictionary                         = false
      optimizeDictionaryForMetrics               = false
      optimizeDictionaryType                     = false
      rangeIndexVersion                          = 2
      loadMode                                   = "MMAP"

      streamConfigs = {
        "streamType"                           = "kafka"
        "stream.kafka.consumer.type"           = "simple"
        "stream.kafka.topic.name"              = "test-topic"
        "stream.kafka.decoder.class.name"      = "org.apache.pinot.plugin.stream.kafka.KafkaJSONMessageDecoder"
        "stream.kafka.broker.list"             = "localhost:9092"
        "realtime.segment.flush.threshold.rows" = "10000"
      }
    }

    metadata = {
      customConfigs = {}
    }

    isDimTable = false
  })
}
`, name)
}

func testAccCheckPinotTableExists(resourceName string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		rs, ok := s.RootModule().Resources[resourceName]
		if !ok {
			return fmt.Errorf("Not found: %s", resourceName)
		}
		if rs.Primary.ID == "" {
			return fmt.Errorf("No Table ID is set")
		}
		status, body, err := pinotGetTableRaw(rs.Primary.ID)
		if err != nil {
			return err
		}
		if status != http.StatusOK {
			return fmt.Errorf("expected table to exist, GET status %d (body: %s)", status, truncate(body, 256))
		}
		// Basic sanity: the body should include the tableName.
		if !strings.Contains(body, `"tableName"`) || !strings.Contains(body, rs.Primary.ID) {
			return fmt.Errorf("unexpected GET body, could not confirm table exists: %s", truncate(body, 256))
		}
		return nil
	}
}

func testAccCheckPinotTableDestroy(s *terraform.State) error {
	const (
		waitTotal = 60 * time.Second
		interval  = 3 * time.Second
	)

	deadline := time.Now().Add(waitTotal)

	for _, rs := range s.RootModule().Resources {
		if rs.Type != "pinot_table" {
			continue
		}

		// Poll until Pinot reports the table is gone or we time out.
		for {
			status, body, err := pinotGetTableRaw(rs.Primary.ID)
			if err != nil {
				return err
			}

			// 404: definitely gone
			if status == http.StatusNotFound {
				break
			}

			// Some Pinot versions return 200 but with an empty or placeholder body after delete.
			// Treat 200 without a valid tableName as "gone".
			if status == http.StatusOK && !looksLikeTableExists(body, rs.Primary.ID) {
				break
			}

			if time.Now().After(deadline) {
				return fmt.Errorf("table still exists after destroy wait: %s (last status %d; body: %s)", rs.Primary.ID, status, truncate(body, 256))
			}
			time.Sleep(interval)
		}
	}
	return nil
}

// ---- HTTP helpers ----

func pinotGetTableRaw(id string) (int, string, error) {
	base := strings.TrimRight(os.Getenv("PINOT_CONTROLLER_URL"), "/")
	if base == "" {
		return 0, "", fmt.Errorf("PINOT_CONTROLLER_URL not set")
	}

	req, err := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/tables/%s", base, id), nil)
	if err != nil {
		return 0, "", err
	}

	// Optional headers: DB + auth
	if db := strings.TrimSpace(os.Getenv("PINOT_DATABASE")); db != "" {
		req.Header.Set("Database", db)
	}
	if token := strings.TrimSpace(os.Getenv("PINOT_TOKEN")); token != "" {
		req.Header.Set("Authorization", "Bearer "+token)
	} else if u, p := os.Getenv("PINOT_USERNAME"), os.Getenv("PINOT_PASSWORD"); u != "" || p != "" {
		req.SetBasicAuth(u, p)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return 0, "", err
	}
	defer resp.Body.Close()

	var buf bytes.Buffer
	_, _ = io.Copy(&buf, resp.Body)
	return resp.StatusCode, buf.String(), nil
}

// looksLikeTableExists inspects JSON and decides if a real table config is present.
func looksLikeTableExists(body string, wantID string) bool {
	// Quick reject: empty or {} or [].
	b := strings.TrimSpace(body)
	if b == "" || b == "{}" || b == "[]" {
		return false
	}

	// Try to parse as a generic map and find tableName.
	var m map[string]any
	if err := json.Unmarshal([]byte(b), &m); err != nil {
		// If JSON is unparsable, fall back to substring heuristic.
		return strings.Contains(b, `"tableName"`) && strings.Contains(b, wantID)
	}

	// tableName present and matches?
	if tn, ok := m["tableName"].(string); ok && tn != "" {
		return strings.EqualFold(tn, wantID)
	}

	// Some controllers wrap under keys; final fallback is substring.
	return strings.Contains(b, `"tableName"`) && strings.Contains(b, wantID)
}

func truncate(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "â€¦"
}
